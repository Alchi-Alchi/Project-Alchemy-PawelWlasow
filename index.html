<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Alchemy</title>
  <link rel="stylesheet" href="css/alchemy.css">
  <link rel="shortcut icon" href="images/stone.png">
  <!-- <script src="js/jquery-3.6.0.js"></script>
  <script src="jquery-ui-1.12.1.custom/jquery-ui.js"></script>
  <script src="jquery-ui-1.12.1.custom/jquery-ui.min.js"></script>
  <script src="jquery-ui-touch-punch/jquery.ui.touch-punch.js"></script>
  <script src="jquery-ui-touch-punch/jquery.ui.touch-punch.min.js"></script> -->
  <script src="js/mobile-drag-drop-master/release/index.js"></script>
  <script src="js/mobile-drag-drop-master/release/index.min.js"></script>
  <script defer src="js/logo.js"></script>
  <script src="js/table.js"></script>
  <script defer src="js/timer.js"></script>
  <script defer src="js/audio.js"></script>
</head>
<body>
  <div id="logo">
    <div class="hamburger-menu">
      <input id="menu__toggle" type="checkbox" />
      <label class="menu__btn" for="menu__toggle">
        <span></span>
      </label>
      <ul class="menu__box">
        <li class="menu__item"><input type="checkbox" id="music" name="yes">Фоновая музыка</li>
        <li class="menu__item"><input type="checkbox" id="sound" name="yes" checked>Звуковые эффекты</li>
      </ul>
    </div>
  </div>
  <div id="wrapper" class="wrapperPages">
  </div>
  <div id="modalWindow" class="modal">
    <p id="nameQ">Введите ваше имя</p>
    <input id="nameA" type="text" placeholder="Name" required><br>
    <button id="modalBtn">OK</button>
    <button id="modalBtnCancel">Отмена</button>
  </div>
  <script>
    window.onhashchange = SwitchToStateFromURLHash;
    let SPAStateH = {}; 
    let wrapper = document.getElementById ('wrapper');
    function SwitchToStateFromURLHash() {
      let URLHash = window.location.hash;
      let StateJSON = decodeURIComponent(URLHash.substr(1));
      if (StateJSON !== "") {
        SPAStateH = JSON.parse(StateJSON);
      } else {
        SPAStateH = {pagename: 'Main'};
      }
      let PageHTML = "";
      switch (SPAStateH.pagename) {
        case 'Rules':
          PageHTML += "<h1 id='header'>Правила</h1>";
          PageHTML += "<div><p id='rules'>В этой игре необходимо открывать новые элементы, путём соединения их друг с другом. Для начала есть 4 основных элемента: Огонь, Вода, Земля, Воздух. Комбинируя их между собой, можно получать новые. На странице с игрой, нажмите кнопку ИГРАТЬ. После этого запустится таймер. Для того, чтобы взять элемент, просто кликните по нему в поле с уже открытыми элементами. Для того, чтобы получить новый, выберите те, что считаете нужными и перетащите их друг к другу. Ненужные элементы можно убрать, перетащив в \"корзину\". Комбинации элементов, могут состоять из двух или более элементов. Игра завершится, когда будут открыты все элементы или по нажатию на кнопку ЗАКОНЧИТЬ ИГРУ.</p></div>";
          wrapper.style.background = 'none';
          logo.style.display = 'flex';
          break;
        case 'Table':
          PageHTML += "<h3 id='header'>Таблица</h3>";
          PageHTML += "<p id='note'><sup>*</sup>Для сортировки таблицы кликните по нужному столбцу</p>";
          PageHTML += "<table id='table' cellpadding ='10'><thead><tr><th data-type='number'>№</th><th data-type='name'>Игрок</th><th data-type='time'>Время</th><th data-type='opened'>Открыто элементов</th></tr></thead><tbody></tbody></table>";
          PageHTML += "<button id='clearBtn'>Очистить таблицу</button>";
          PageHTML += "<p id='message'></p>";
          wrapper.style.background = 'none';
          logo.style.display = 'flex';
          break;
          case 'Main':
          wrapper.style.background = 'url(images/background.png)';
          wrapper.style.backgroundSize = 'cover';
          logo.style.display = 'none';
          break;
        case 'Game':
          PageHTML += "<div id='container'>";
          PageHTML += "<div id='basket' class='droppable basketUsual'></div>";
          PageHTML += "<div id='workField' class='fieldForTransform'>";
          PageHTML += "<div id='counter'>";
          PageHTML += "<div id='count'>";
          PageHTML += "<span id='openedElements'></span>";
          PageHTML += "<span id='slash'>/</span>";
          PageHTML += "<span id='allElements'></span>";
          PageHTML += "</div>";
          PageHTML += "</div>";
          PageHTML += "<div id='start'><button id='startBtn'>Играть</button></div>";
          PageHTML += "</div>";
          PageHTML += "<div id='bankOfElements'>";
          PageHTML += "<img src='icons/air.png' alt='air' title='Воздух' class='base' id='air' name='air'>";
          PageHTML += "<img src='icons/flame.png' alt='flame' title='Огонь' class='base' id='flame' name='flame'>";
          PageHTML += "<img src='icons/ground.png' alt='ground' title='Земля' class='base' id='ground' name='ground'>"; 
          PageHTML += "<img src='icons/water.png' alt='water' title='Вода' class='base' id='water' name='water'>";
          PageHTML += "</div>";  
          PageHTML += "</div>";
          wrapper.style.background = 'none';
          logo.style.display = 'flex';
          break;   
      }
      document.getElementById('wrapper').innerHTML = PageHTML;
      if (SPAStateH = {pagename: 'Table'}) {
        tableAdd ();
      };
      if (SPAStateH = {pagename: 'Game'}) {
      };
    }
    function SwitchToState(NewStateH) {
      location.hash = encodeURIComponent(JSON.stringify(NewStateH));
    }
    function SwitchToRulesPage() {
      SwitchToState({pagename: 'Rules'});
    }
    function SwitchToListPage() {
      SwitchToState({pagename: 'Table'});
    }
    function SwitchToGamePage() {
      SwitchToState({pagename: 'Game'});
      location.reload();
    }
    function SwitchToMainPage() {
      SwitchToState({pagename: 'Main'});
    }
    SwitchToStateFromURLHash();
  </script>
  <script>
    MobileDragDrop.polyfill({
      dragImageTranslateOverride: MobileDragDrop.scrollBehaviourDragImageTranslateOverride
    });
    

        //        var DEBUG = false;

        var allowDragWithTwoFingersOnly = function (event) {

// only allow drag with two fingers
return (event.touches.length === 2);
};

var threshold = 10;
var startX, startY;

var allowHorizontalDragOnly = function (event) {

var touch = event.touches[0];

if (startX === undefined || startY === undefined) {
    startX = touch.clientX;
    startY = touch.clientY;

    // we are uncertain if we shall start a drag operation.. return undefined
    return;
}

var deltaX = Math.abs(startX - touch.clientX),
    deltaY = Math.abs(startY - touch.clientY);

console.log("startX: " + startX);
console.log("startY: " + startY);

console.log("deltaX: " + deltaX);
console.log("deltaY: " + deltaY);

if (deltaX > threshold || deltaY > threshold) {

    console.log("threshold reached.");

    // reset our initial values
    startX = undefined;
    startY = undefined;

    if (deltaX > deltaY) {

        console.log('horizontal drag detected, starting drag');
        // we know for sure to start it, return true
        return true;
    }
    else {

        console.log('vertical scroll detected, aborting drag');
        // we know for sure to abort it, return false
        return false;
    }
}
};

var alertAction = function (event) {

event.stopImmediatePropagation();
event.preventDefault();
alert("I'm your default action override");
return true;
};

var polyfillApplied = MobileDragDrop.polyfill({
//            dragImageCenterOnTouch: true,
//            dragImageOffset: {
//                x: 0,
//                y: 0
//            },
//            dragStartConditionOverride: allowHorizontalDragOnly,
//            defaultActionOverride: alertAction,
dragImageTranslateOverride: MobileDragDrop.scrollBehaviourDragImageTranslateOverride,
// holdToDrag: 300
});

var appliedMessageEl = document.getElementById("appliedMessage");
var appliedMessage = "Polyfill inactive: Current browser was detected to handle drag'n'drop quite well on its own ;)";
if (polyfillApplied) {

appliedMessage = "Polyfill activated: Detected current browser not capable of HTML5 drag'n'drop (or somebody set forceApply is to true)";
}
appliedMessageEl.innerHTML = appliedMessage;

/**
* ---------------------------------------------------------------------------------------------------------
*/

var missed = ['hey!', 'missed it :(', 'that was close..', 'ARRRR'];
var eat = ['yum!', 'gulp', 'burp!', 'nom'];
var yum = document.createElement('p');

/**
* ---------------------------------------------------------------------------------------------------------
*/

var links = document.querySelectorAll('li > a'), el = null;
for (var i = 0; i < links.length; i++) {
el = links[i];

el.setAttribute('draggable', 'true');

addEvent(el, 'dragstart', function (e) {
    console.log('dragstart');

    e.dataTransfer.effectAllowed = 'copyLink';

    //TODO fails on desktop safari because drag is immediately aborted
//                this.style.display = "none";

    console.log('setting data: ' + this.id);

    e.dataTransfer.setData('Text', this.id); // required otherwise doesn't work
});

addEvent(el, 'drag', function (e) {
    console.log('drag');
});

addEvent(el, 'dragend', function (e) {

//                this.style.display = "block";

    console.log('dragend with effect: ' + e.dataTransfer.dropEffect);
});

addEvent(el, 'click', function (e) {
    console.log('clicked on draggable');

    console.log('click offsetX, offsetY: ' + e.offsetX + ", " + e.offsetY);
});
}

var draggables = document.querySelectorAll('.draggable');
var dragHandles = document.querySelectorAll('.drag-handle');
var noDrags = document.querySelectorAll('.no-drag');

for (var i = 0; i < draggables.length; i++) {
makeElementDraggable(draggables[i]);
}

for (var i = 0; i < dragHandles.length; i++) {
makeElementDragHandle(dragHandles[i]);
}

for (var i = 0; i < noDrags.length; i++) {

makeElementNoDrag(noDrags[i]);
}

function makeElementDraggable(element) {

element.setAttribute('draggable', 'true');

addEvent(element, 'dragstart', function (e) {

    // Check whether the element is draggable, since dragstart might be triggered on a child.
    if (element.getAttribute('draggable') == 'false') return true;

    console.log('dragstart');

    e.dataTransfer.effectAllowed = 'copyLink';

    console.log('setting data: ' + this.id);

    e.dataTransfer.setData('Text', this.id); // required otherwise doesn't work

    // Try setting a proper drag image if triggered on a dnd-handle (won't work in IE).
    if (e._dndHandle && e.dataTransfer.setDragImage) {

        e.dataTransfer.setDragImage(element);
    }
});

addEvent(element, 'drag', function (e) {
    console.log('drag');
});

addEvent(element, 'dragend', function (e) {
    console.log('dragend with effect: ' + e.dataTransfer.dropEffect);
});

addEvent(element, 'click', function (e) {
    console.log('clicked on draggable');
});
}

function makeElementDragHandle(element) {
element.setAttribute('draggable', 'true');

addEvent(element, 'dragstart', function (event) {
    console.log("drag handle start");
    event._dndHandle = true;
});

addEvent(element, 'dragend', function (event) {
    console.log("drag handle end");
    event._dndHandle = true;
});
}

function makeElementNoDrag(element) {

// Set as draggable so that we can cancel the events explicitly
element.setAttribute('draggable', 'true');

/**
 * Since the element is draggable, the browser's default operation is to drag it on dragstart.
 * We will prevent that and also stop the event from bubbling up.
 */
addEvent(element, 'dragstart', function (event) {

    console.log("nodrag: dragstart");

    if (!event._dndHandle) {

        console.log("nodrag: no dnd handle");
        // If a child element already reacted to dragstart and set a dataTransfer object, we will
        // allow that. For example, this is the case for user selections inside of input elements.
        if (!(event.dataTransfer.types && event.dataTransfer.types.length)) {

            console.log("nodrag: prevent default");
            event.preventDefault();
        }
        console.log("nodrag: stopPropagation");
        event.stopPropagation();
    }
});

/**
 * Stop propagation of dragend events, otherwise dnd-moved might be triggered and the element
 * would be removed.
 */
addEvent(element, 'dragend', function (event) {
    if (!event._dndHandle) {
        event.stopPropagation();
    }
});
}

/**
* ---------------------------------------------------------------------------------------------------------
*/

var bin = document.querySelector('#bin');

addEvent(bin, 'dragenter', function (e) {
console.log('bin dragenter');

console.log('bin offsetX, offsetY: ' + e.offsetX + ", " + e.offsetY);

e.preventDefault();
e.stopPropagation(); // stop it here to prevent it bubble up

bin.classList.add('over');

});

addEvent(bin, 'dragover', function (e) {
console.log('bin dragover');

console.log('bin offsetX, offsetY: ' + e.offsetX + ", " + e.offsetY);

e.preventDefault(); // allows us to drop
e.stopPropagation(); // stop it here to prevent it bubble up

e.dataTransfer.dropEffect = 'link'; // we have to set it for firefox to be happy
});

addEvent(bin, 'dragexit', function (e) {
console.log('bin dragexit');

console.log('bin offsetX, offsetY: ' + e.offsetX + ", " + e.offsetY);

e.stopPropagation(); // stop it here to prevent it bubble up
});

addEvent(bin, 'dragleave', function (e) {
console.log('bin dragleave');

console.log('bin offsetX, offsetY: ' + e.offsetX + ", " + e.offsetY);

e.stopPropagation(); // stop it here to prevent it bubble up

bin.classList.remove('over');
});

addEvent(bin, 'drop', function (e) {
console.log('bin drop');

console.log('bin offsetX, offsetY: ' + e.offsetX + ", " + e.offsetY);

e.stopPropagation(); // stop it here to prevent it bubble up

// stupid nom text + fade effect
yum.innerHTML = missed[parseInt(Math.random() * missed.length)];

var y = yum.cloneNode(true);
bin.appendChild(y);

setTimeout(function () {
    y.classList.add('fadeout');
}, 250);
});

/**
* ---------------------------------------------------------------------------------------------------------
*/

var innerBin = document.querySelector('#innerBin');

bin.classList.add('zoom');

addEvent(innerBin, 'dragenter', function (e) {
console.log('apperture dragenter');

e.preventDefault();
e.stopPropagation(); // stop it here to prevent it bubble up

bin.classList.add('in');
});

addEvent(innerBin, 'dragover', function (e) {
console.log('apperture dragover');

e.preventDefault(); // allows us to drop
e.stopPropagation(); // stop it here to prevent it bubble up

e.dataTransfer.dropEffect = 'copy';
});

addEvent(innerBin, 'dragexit', function (e) {
console.log('apperture dragexit');

e.stopPropagation(); // stop it here to prevent it bubble up

bin.classList.remove('in');
});

addEvent(innerBin, 'dragleave', function (e) {
console.log('apperture dragleave');

e.stopPropagation(); // stop it here to prevent it bubble up

bin.classList.remove('in');
});

addEvent(innerBin, 'drop', function (e) {
console.log('apperture drop');

e.stopPropagation(); // stop it here to prevent it bubble up

bin.classList.remove('in');

var el = document.getElementById(e.dataTransfer.getData('Text'));

el.parentNode.removeChild(el);

// stupid nom text + fade effect
yum.innerHTML = eat[parseInt(Math.random() * eat.length)];

var y = yum.cloneNode(true);
bin.appendChild(y);

setTimeout(function () {
    y.classList.add('fadeout');
}, 250);
});


//        /**
//         * ---------------------------------------------------------------------------------------------------------
//         */
//
//
//        var flexboxedDraggables = document.querySelectorAll('ul > li.flex-boxed');
//        for (var k = 0; k < flexboxedDraggables.length; k++) {
//            var flexboxedDraggable = flexboxedDraggables[k];
//
//            if (flexboxedDraggable.hasAttribute('draggable') === false) {
//                console.log('setting flexboxed item draggable programmatically');
//
//                flexboxedDraggable.setAttribute('draggable', 'true');
//            }
//
//            addEvent(flexboxedDraggable, 'dragstart', function (e) {
//                console.log('dragstart');
//
//                e.dataTransfer.effectAllowed = 'copyMove';
//                e.dataTransfer.setData('Text', "Test"); // required otherwise doesn't work
//            });
//
//            addEvent(flexboxedDraggable, 'drag', function (e) {
//                console.log('drag');
//            });
//
//            addEvent(flexboxedDraggable, 'dragend', function (e) {
//                console.log('dragend with effect: ' + e.dataTransfer.dropEffect);
//            });
//
//            addEvent(el, 'click', function (e) {
//                console.log('clicked on draggable');
//
//                console.log('click offsetX, offsetY: ' + e.offsetX + ", " + e.offsetY);
//            });
//        }
//
//
//        var flexboxedDropzones = document.querySelectorAll('.flex-boxed.dropzone');
//
//        for (var j = 0; j < flexboxedDropzones.length; j++) {
//            var flexboxedDropzone = flexboxedDropzones[j];
//
//            addEvent(flexboxedDropzone, 'dragenter', function (e) {
//                console.log('flexbox dropzone dragenter');
//
//                e.preventDefault();
//                e.stopPropagation(); // stop it here to prevent it bubble up
//            });
//
//            addEvent(flexboxedDropzone, 'dragover', function (e) {
//                console.log('flexbox dropzone dragover');
//
//                e.preventDefault(); // allows us to drop
//                e.stopPropagation(); // stop it here to prevent it bubble up
//
//                e.dataTransfer.dropEffect = 'copy';
//            });
//
//            addEvent(flexboxedDropzone, 'dragexit', function (e) {
//                console.log('flexbox dropzone dragexit');
//
//                e.stopPropagation(); // stop it here to prevent it bubble up
//            });
//
//            addEvent(flexboxedDropzone, 'dragleave', function (e) {
//                console.log('flexbox dropzone dragleave');
//
//                e.stopPropagation(); // stop it here to prevent it bubble up
//            });
//
//            addEvent(flexboxedDropzone, 'drop', function (e) {
//                console.log('flexbox dropzone drop');
//
//                e.stopPropagation(); // stop it here to prevent it bubble up
//            });
//
//        }
//
//        /**
//         * ---------------------------------------------------------------------------------------------------------
//         */
//
//        var complexDraggables = document.querySelectorAll('.det.draggable');
//        var nestedComplexDraggables = document.querySelectorAll('.oic.draggable');
//
//        var allComplexDraggables = [].concat(nestedComplexDraggables).concat(complexDraggables);
//
//        allComplexDraggables.forEach(function (item) {
//
//            addEvent(item, 'dragstart', function (event) {
//
////            this.isInProgress = true;  // Progress styling
//                event.dataTransfer.effectAllowed = 'move';
//                event.dataTransfer.setData('text', 'foo');
//
////        this.onDragStart.trigger(event); // Custom event
//            });
//
//            addEvent(item, 'dragend', function (event) {
//
////            this.isInProgress = false; // Progress styling
//                var dropOccurred = event.dataTransfer.dropEffect !== 'none';
//
////        this.onDragEnd.trigger(event.create(dropOccurred)); // Custom event
//            });
//
//            addEvent(item, 'click', function (event) {
//
//                alert('clicked on complex draggable');
//            });
//        });
//
//        /**
//         * ---------------------------------------------------------------------------------------------------------
//         */
//
//        var customDragImageDraggable = document.querySelectorAll('ul > li.custom');
//        for (var k = 0; k < flexboxedDraggables.length; k++) {
//            var customDragImage = customDragImageDraggable[k];
//            var clone;
//            addEvent(customDragImage, 'dragstart', function (event) {
//
//                event.dataTransfer.effectAllowed = 'move';
//                event.dataTransfer.setData('text', 'foo');
//
//                clone = this.cloneNode(true);
//                clone.innerHTML = "im custom!";
//                clone.style.backgroundColor = "red";
//
//                document.body.appendChild(clone);
//
//                event.dataTransfer.setDragImage(clone, 10, 10);
//            });
//
//            addEvent(customDragImage, 'dragend', function (event) {
//
//                document.body.removeChild(clone);
//                clone = null;
//            });
//        }

// tmp fix for iOS10 touchmove bug (https://github.com/timruffles/ios-html5-drag-drop-shim/issues/77)
try {
window.addEventListener('touchmove', function () {
}, {passive: false})
} catch(e) {}
</script>
  <div id="menu">
    <button id="gamePage" onclick='SwitchToGamePage()'>К игре</button>
    <button id="scoreBtn" data-tooltip="Внимание! Если покинуть страницу, весь прогресс будет потерян" onclick='SwitchToListPage()'>Таблица рекордов</button>
    <span id="timer">00:00:00</span>
    <button id="rulesBtn" data-tooltip="Внимание! Если покинуть страницу, весь прогресс будет потерян" onclick='SwitchToRulesPage()'>Правила</button>
    <button id="endGame" data-tooltip="Внимание! Если покинуть страницу, весь прогресс будет потерян" onclick='SwitchToMainPage()'>Закончить игру</button>
  </div>
</body> 
<script src="js/dragElements.js"></script>
<script src="js/count.js"></script>
<script src="js/behaviorElements.js"></script>
</html>